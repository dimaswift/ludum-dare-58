#pragma kernel GenerateGeodesic

struct Vertex
{
    float3 position;
    float3 normal;
};

RWStructuredBuffer<Vertex> VertexBuffer;
RWStructuredBuffer<uint> IndexBuffer;

uint Subdivisions;
float Radius;

static const float PHI = 1.618033988749895;

static const float3 IcoVertices[12] = {
    normalize(float3(-1,  PHI,  0)),
    normalize(float3( 1,  PHI,  0)),
    normalize(float3(-1, -PHI,  0)),
    normalize(float3( 1, -PHI,  0)),
    
    normalize(float3( 0, -1,  PHI)),
    normalize(float3( 0,  1,  PHI)),
    normalize(float3( 0, -1, -PHI)),
    normalize(float3( 0,  1, -PHI)),
    
    normalize(float3( PHI,  0, -1)),
    normalize(float3( PHI,  0,  1)),
    normalize(float3(-PHI,  0, -1)),
    normalize(float3(-PHI,  0,  1))
};

static const int3 IcoFaces[20] = {
    int3(0, 11, 5), int3(0, 5, 1), int3(0, 1, 7), int3(0, 7, 10), int3(0, 10, 11),
    int3(1, 5, 9), int3(5, 11, 4), int3(11, 10, 2), int3(10, 7, 6), int3(7, 1, 8),
    int3(3, 9, 4), int3(3, 4, 2), int3(3, 2, 6), int3(3, 6, 8), int3(3, 8, 9),
    int3(4, 9, 5), int3(2, 4, 11), int3(6, 2, 10), int3(8, 6, 7), int3(9, 8, 1)
};

[numthreads(64, 1, 1)]
void GenerateGeodesic(uint3 id : SV_DispatchThreadID)
{
    // Calculate total triangles after subdivision
    uint trianglesPerFace = 1 << (2 * Subdivisions); // 4^subdivisions
    uint totalTriangles = 20 * trianglesPerFace;
    
    if (id.x >= totalTriangles)
        return;
    
    // Determine which base face and which sub-triangle
    uint faceIdx = id.x / trianglesPerFace;
    uint subTriIdx = id.x % trianglesPerFace;
    
    // Get base triangle
    int3 face = IcoFaces[faceIdx];
    float3 v0 = IcoVertices[face.x] * Radius;
    float3 v1 = IcoVertices[face.y] * Radius;
    float3 v2 = IcoVertices[face.z] * Radius;
    
    // Iteratively subdivide to find the specific triangle
    for (uint level = 0; level < Subdivisions; level++)
    {
        // Which quadrant (0-3) at this level?
        uint quadrant = (subTriIdx >> (2 * (Subdivisions - level - 1))) & 3;
        
        // Calculate edge midpoints
        float3 m01 = normalize((v0 + v1) * 0.5) * Radius;
        float3 m12 = normalize((v1 + v2) * 0.5) * Radius;
        float3 m20 = normalize((v2 + v0) * 0.5) * Radius;
        
        // Select quadrant
        if (quadrant == 0) {
            v1 = m01;
            v2 = m20;
        } else if (quadrant == 1) {
            v0 = v1;
            v1 = m12;
            v2 = m01;
        } else if (quadrant == 2) {
            v0 = v2;
            v1 = m20;
            v2 = m12;
        } else { // quadrant == 3
            v0 = m01;
            v1 = m12;
            v2 = m20;
        }
    }
    
    // Write final triangle
    uint baseVertexIdx = id.x * 3;
    uint baseIndexIdx = id.x * 3;
    
    Vertex vert0, vert1, vert2;
    vert0.position = v0;
    vert0.normal = normalize(v0);
    vert1.position = v1;
    vert1.normal = normalize(v1);
    vert2.position = v2;
    vert2.normal = normalize(v2);
    
    VertexBuffer[baseVertexIdx + 0] = vert0;
    VertexBuffer[baseVertexIdx + 1] = vert1;
    VertexBuffer[baseVertexIdx + 2] = vert2;
    
    IndexBuffer[baseIndexIdx + 0] = baseVertexIdx + 0;
    IndexBuffer[baseIndexIdx + 1] = baseVertexIdx + 1;
    IndexBuffer[baseIndexIdx + 2] = baseVertexIdx + 2;
}