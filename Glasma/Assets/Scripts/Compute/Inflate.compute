#pragma kernel GenerateGeodesicShared
#pragma kernel RelaxVertices
#pragma kernel UpdateCentroid
#pragma kernel RecalculateNormals
#include "Assets/Scripts/Compute/QuantumField.cginc"
struct Vertex
{
    float3 position;
    float3 normal;
};

struct VertexDynamics
{
    float3 velocity;
    float mass;
};

RWStructuredBuffer<Vertex> VertexBuffer;
RWStructuredBuffer<uint> IndexBuffer;
RWStructuredBuffer<VertexDynamics> DynamicsBuffer;
RWStructuredBuffer<float3> Centroid;

float DeltaTime;
float InflationPressure;
float Damping;
float TargetRadius;
float RadialStiffness;
uint TriangleCount;
uint VertexCount;
uint Subdivisions;
float Radius;
float EscapeRadius;
float Soften;
float Density;
float Frequency;
float Size;
float Scale;
float Surface;
// ============================================================================
// Icosahedron base
// ============================================================================

static const float PHI = 1.618033988749895;

static const float3 IcoVertices[12] = {
    normalize(float3(-1,  PHI,  0)),
    normalize(float3( 1,  PHI,  0)),
    normalize(float3(-1, -PHI,  0)),
    normalize(float3( 1, -PHI,  0)),
    normalize(float3( 0, -1,  PHI)),
    normalize(float3( 0,  1,  PHI)),
    normalize(float3( 0, -1, -PHI)),
    normalize(float3( 0,  1, -PHI)),
    normalize(float3( PHI,  0, -1)),
    normalize(float3( PHI,  0,  1)),
    normalize(float3(-PHI,  0, -1)),
    normalize(float3(-PHI,  0,  1))
};

static const int3 IcoFaces[20] = {
    int3(0, 11, 5), int3(0, 5, 1), int3(0, 1, 7), int3(0, 7, 10), int3(0, 10, 11),
    int3(1, 5, 9), int3(5, 11, 4), int3(11, 10, 2), int3(10, 7, 6), int3(7, 1, 8),
    int3(3, 9, 4), int3(3, 4, 2), int3(3, 2, 6), int3(3, 6, 8), int3(3, 8, 9),
    int3(4, 9, 5), int3(2, 4, 11), int3(6, 2, 10), int3(8, 6, 7), int3(9, 8, 1)
};

// ============================================================================
// KERNEL 1: Generate geodesic with SHARED vertices
// ============================================================================
// This is more complex - we need to:
// 1. Generate unique vertices only once
// 2. Build an index buffer that references shared vertices
// 3. Use a hash map or ordered generation to avoid duplicates

// Helper: Hash a vertex position to detect duplicates
uint HashVertex(float3 v, float precision)
{
    // Quantize to grid
    int3 quantized = int3(v * precision);
    // Simple hash function
    return (quantized.x * 73856093) ^ (quantized.y * 19349663) ^ (quantized.z * 83492791);
}

// For simplicity, we'll use a different approach:
// Generate vertices in a predictable order that naturally avoids duplicates

[numthreads(64, 1, 1)]
void GenerateGeodesicShared(uint3 id : SV_DispatchThreadID)
{
    // This is complex to do in parallel with vertex sharing
    // For now, we'll use a simplified approach where CPU does initial generation
    // and GPU only handles physics
    
    // TODO: Implement proper shared vertex generation
    // This requires either:
    // 1. CPU pre-processing to build vertex map
    // 2. GPU hash table for deduplication
    // 3. Ordered generation with mathematical indexing
}

// ============================================================================
// KERNEL 2: Update Centroid
// ============================================================================

groupshared float3 sharedSum;
groupshared uint sharedCount;

[numthreads(64, 1, 1)]
void UpdateCentroid(uint3 id : SV_DispatchThreadID, uint3 gid : SV_GroupThreadID, uint3 groupID : SV_GroupID)
{
    // Initialize shared memory
    if (gid.x == 0)
    {
        sharedSum = float3(0, 0, 0);
        sharedCount = 0;
    }
    GroupMemoryBarrierWithGroupSync();
    
    // Accumulate positions
    if (id.x < VertexCount)
    {
        Vertex v = VertexBuffer[id.x];
        
        // Atomic add to shared memory (approximate for float3)
        // Note: This is not perfect but works for averaging
        InterlockedAdd(sharedCount, 1);
        
        // For simplicity, just do local accumulation
        sharedSum += v.position;
    }
    
    GroupMemoryBarrierWithGroupSync();
    
    // First thread in each group writes partial result
    if (gid.x == 0 && sharedCount > 0)
    {
        // Store partial sum (in real implementation, do multi-stage reduction)
        float3 avg = sharedSum / float(sharedCount);
        Centroid[0] = avg; // Simplified: overwrites instead of accumulates
    }
}

// ============================================================================
// KERNEL 3: Relax Vertices (Main Physics)
// ============================================================================

[numthreads(64, 1, 1)]
void RelaxVertices(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= VertexCount)
        return;

    Vertex p = VertexBuffer[id.x];
    FieldConfig cfg;
    cfg.radius = Radius;
    cfg.phase = 0;
    cfg.frequency = Frequency;
    cfg.density = Density;
   // cfg.colors = IcoVertices;
    cfg.dt = DeltaTime;
    cfg.soften = Soften;
    float3 position = (p.position) * exp2(Scale);

    float3 core = float3(0,0,0);

    float3 density = float3(0,0,0);
    int c = 0;
    for (int x = -1; x <= 1; ++x)
    {
        for (int y = -1; y <= 1; ++y)
        {
            for (int z = -1; z <= 1; ++z)
            {
                if(x == 0 && y == 0 && z == 0) continue;
                float3 off = position + float3(x, y, z) * Size;
                Trajectory t_top = SampleField(3, off, core, EscapeRadius, cfg);
                density += normalize(float3(x, y, z)) * (t_top.energy);
                c++;
            }
        }
    }
    density /= c;

    p.position += density * InflationPressure;
    
    VertexBuffer[id.x] = p;
}

// ============================================================================
// KERNEL 4: Recalculate normals from triangles
// ============================================================================

[numthreads(64, 1, 1)]
void RecalculateNormals(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= TriangleCount)
        return;
    
    // Load triangle indices
    uint baseIdx = id.x * 3;
    uint idx0 = IndexBuffer[baseIdx + 0];
    uint idx1 = IndexBuffer[baseIdx + 1];
    uint idx2 = IndexBuffer[baseIdx + 2];
    
    // Load positions
    float3 p0 = VertexBuffer[idx0].position;
    float3 p1 = VertexBuffer[idx1].position;
    float3 p2 = VertexBuffer[idx2].position;
    
    // Calculate face normal
    float3 edge1 = p1 - p0;
    float3 edge2 = p2 - p0;
    float3 faceNormal = normalize(cross(edge1, edge2));
    
    // Accumulate to vertex normals (atomic operations would be needed for correctness)
    // For now, we'll just set the normal (this creates faceted look)
    // In production, use atomic adds and normalize afterward
    
    Vertex v0 = VertexBuffer[idx0];
    Vertex v1 = VertexBuffer[idx1];
    Vertex v2 = VertexBuffer[idx2];
    
    // Simple averaging (not thread-safe, but approximate)
    v0.normal = lerp(v0.normal, faceNormal, 0.1);
    v1.normal = lerp(v1.normal, faceNormal, 0.1);
    v2.normal = lerp(v2.normal, faceNormal, 0.1);
    
    VertexBuffer[idx0] = v0;
    VertexBuffer[idx1] = v1;
    VertexBuffer[idx2] = v2;
}