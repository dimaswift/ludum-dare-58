#pragma kernel Construct
#pragma kernel Clear
#pragma kernel InitHoleMask
#pragma kernel AddHole
#pragma kernel AddHoleSoft
#pragma kernel AddSphere 

#define SIZEOF_UINT 4
#define SIZEOF_FLOAT3 12

#include "Assets/Scripts/Compute/Masks.cginc"

#include "Assets/Scripts/Compute/QuantumField.cginc"

RWByteAddressBuffer VertexBuffer;
RWByteAddressBuffer IndexBuffer;
RWStructuredBuffer<uint> Counter;
StructuredBuffer<uint2> TriangleTable;
StructuredBuffer<Photon> Photons;
StructuredBuffer<SculptSolid> Solids;
RWTexture3D<float> HoleMask;
Texture3D<float> Field;
uint3 HoleMaskDims; 
 
uint3 Dims;
uint MaxTriangle;
uint FlipNormals;
uint InvertTriangles; 
int SolidCount;
uint3 HolePosition;
uint3 HoleSize;
float HoleValue;

float4x4 ParentMatrix;
float4x4 ChildMatrix;
float Radius;
float TimeStep;
float EscapeRadius;
float Soften;
float Density;
float Frequency;
float Size;
float3 Scale;
float Surface;
int Steps;
float3 Offset;
float4x4 PhotonTransform;


float3 TransformPoint(float3 p)
{
    return (p + 0.5 - Dims / 2) * (1.0 / Dims.x);
}

uint EdgeIndexFromTriangleTable(uint2 data, uint index)
{
    return 0xfu & (index < 8 ? data.x >> ((index + 0) * 4) :
                               data.y >> ((index - 8) * 4));
}

float expDecay(float a, float b, float decay, float t)
{
    return b + (a - b) * exp (-decay * t);
}


float sampleMask(uint3 id)
{
    
    if (id.x == 0 || id.y == 0 || id.z == 0 || id.x == Dims.x || id.y == Dims.y || id.z == Dims.z)
    {
       return 0;
    }
    //

    // float3 uvw = (float3)id / (float3)Dims;
    // uint3 holeMaskCoord = (uint3)(uvw * (float3)HoleMaskDims);
    // holeMaskCoord = min(holeMaskCoord, HoleMaskDims - 1);
    //
    // float holeMask = HoleMask[holeMaskCoord];
    //
    // if (holeMask < 1)
    // {
    //     return 0; // Inside hole
    // }
    //
    
   float ux = float(id.x - float(Dims.x) * 0.5) / Dims.x;
   float uy = float(id.y - float(Dims.y) * 0.5) / Dims.x;
   float uz = float(id.z - float(Dims.z) * 0.5) / Dims.x;
    
 //   float3 p = float3(ux, uy, uz);
  //  FieldConfig cfg;
 //   cfg.radius = Radius;
  //  cfg.phase = 0;
  //  cfg.frequency = Frequency;
   // cfg.density = Density;
    // cfg.colors = IcoVertices;
 //   cfg.dt = TimeStep;
  //  cfg.soften = Soften;
    float msk = 1;
    
 
    // 3. Transform the world position back into the parent's "fractal space"
    //    This is the key step that makes the fractal "stick" to the cube.
  //  float3 fractalPos = mul(ParentMatrix, float4(p, 1.0)).xyz;

    // 4. Apply the final global fractal scaling
  //  float3 finalSamplePos = (fractalPos + Offset) * exp(Scale);

    //Trajectory v = SampleField(Steps, finalSamplePos, float3(0,0,0), EscapeRadius, cfg, Photons[0]);
    float e = Field[id];
  //  e+=Field[uint3(id.x + 1, ind.y, ind.z)];
    // int c = 0;
    // for (int x = -1; x <= 1; ++x)
    // {
    //     for (int y = -1; y <= 1; ++y)
    //     {
    //         for (int z = -1; z <= 1; ++z)
    //         {
    //             int3 ind = id + int3(x,y,z);
    //             if(ind.x < 0 || id.x >= Dims.x || ind.y < 0 || id.y >= Dims.y || ind.z < 0 || id.z >= Dims.z)
    //             {
    //                 continue;
    //             }
    //             e+=Field[uint3(ind.x, ind.y, ind.z)];
    //             c++;
    //         }
    //     }
    // }

    //e/=c;
    
  //  float m = evaluateSolidField(p, Solids[0]);


    return exp(-e) + Density;
}

float random (float3 uv)
{
    return frac(sin(dot(uv,float3(12.9898,78.233,5617.233)))*43758.5453123);
}

// Dispatch with [numthreads(8,8,8)]
[numthreads(8,8,8)]
void AddSphere (uint3 id : SV_DispatchThreadID)
{
    // Get texture dimensions
    uint width, height, depth;
    HoleMask.GetDimensions(width, height, depth);
    
    // Check bounds
    if (id.x >= width || id.y >= height || id.z >= depth)
        return;
    
    // Calculate center of the volume
    float3 center = float3(width, height, depth) * 0.5;
    
    // Calculate distance from current voxel to center
    float3 pos = float3(id.x, id.y, id.z);

    float v = 0;

    // if(pos.x >= center.x - Radius && pos.x <= center.x + Radius && pos.y >= center.y - Radius && pos.y <= center.y + Radius && pos.z >= center.z - Radius && pos.z <= center.z + Radius)
    // {
    //     v = 1.0;
    // }
    //
    float distance = length(pos - center);
    
    // Define your sphere radius
    float radius = Radius; // Adjust this value
    
    // Set voxel value: 1.0 if inside sphere, 0.0 if outside
    v = distance <= radius ? 1.0 : 0.0;

    if(id.x == (int)Frequency)
    {
        v = 1;
    }
    
    HoleMask[id] = v;
    
}

[numthreads(1, 1, 1)]
void InitHoleMask(uint3 id : SV_DispatchThreadID)
{
    HoleMask[id] = 0.0; 
}

[numthreads(1, 1, 1)]
void AddHole(uint3 id : SV_DispatchThreadID)
{
    uint3 writePos = HolePosition + id;
    
    // Bounds check
    if (any(writePos >= HoleMaskDims)) return;
    
    // Write hole value
    HoleMask[writePos] = 1.0;
}

[numthreads(1, 1, 1)]
void AddHoleSoft(uint3 id : SV_DispatchThreadID)
{
    uint3 writePos = HolePosition + id;
    if (any(writePos >= HoleMaskDims)) return;
    
    // Calculate distance from center for smooth falloff
    float3 center = (float3)HoleSize * 0.5;
    float3 delta = (float3)id - center;
    float dist = length(delta);
    float maxDist = length(center);
    
    // Smooth falloff (1.0 at edge, 0.0 at center)
    float falloff = saturate(dist / maxDist);
    
    HoleMask[writePos] = min(HoleMask[writePos], falloff);
}

float sampleFieldVoxel(uint x, uint y, uint z)
{
    return sampleMask(uint3(x,y,z));
}

float4 VoxelValueWithGradient(uint3 i)
{
    const uint3 i_n = max(i, 1) - 1;
    const uint3 i_p = min(i + 1, Dims);
    
    // Sample the field values
    const float center = sampleFieldVoxel(i.x, i.y, i.z);
    const float v_nx = sampleFieldVoxel(i_n.x, i.y, i.z);
    const float v_px = sampleFieldVoxel(i_p.x, i.y, i.z);
    const float v_ny = sampleFieldVoxel(i.x, i_n.y, i.z);
    const float v_py = sampleFieldVoxel(i.x, i_p.y, i.z);
    const float v_nz = sampleFieldVoxel(i.x, i.y, i_n.z);
    const float v_pz = sampleFieldVoxel(i.x, i.y, i_p.z);
    
    // Calculate gradient from the original field (this gives us correct normals)
    const float3 gradient = float3(v_px - v_nx, v_py - v_ny, v_pz - v_nz);
    
    float marchingValue = center - Surface;
    
    return float4(gradient, marchingValue);
}

void WriteVertex(uint offset, float3 p, float3 n)
{
    uint addr_p = offset * SIZEOF_FLOAT3 * 2;
    uint addr_n = addr_p + SIZEOF_FLOAT3; 
    VertexBuffer.Store3(addr_p, asuint(p));
    VertexBuffer.Store3(addr_n, asuint(n));
}

void WriteIndices(uint offset, uint3 indices)
{
    IndexBuffer.Store3(offset * SIZEOF_UINT, indices);
}

uint3 CubeVertex(uint index)
{
    bool x = index & 1;
    bool y = index & 2;
    bool z = index & 4;
    return uint3(x ^ y, y, z);
}

uint2 EdgeVertexPair(uint index)
{
    uint v1 = index & 7;
    uint v2 = index < 8 ? ((index + 1) & 3) | (index & 4) : v1 + 4;
    return uint2(v1, v2);
}

[numthreads(8, 8, 1)]
void Construct(uint3 id : SV_DispatchThreadID)
{
    uint i;
    
    float totalAlpha = 0;
    [unroll]
    for (i = 0; i < 8; i++)
    {
        float a = sampleMask(id + CubeVertex(i));
        totalAlpha += a;
    }

    if (totalAlpha == 0) return;

    float4 samples[8];

  //  [unroll]
    for (i = 0; i < 8; i++)
        samples[i] = VoxelValueWithGradient(id + CubeVertex(i));

    uint selector = 0;
    [unroll]
    for (i = 0; i < 8; i++)
        selector |= (samples[i].w > 0) << i;
    
    if (selector == 0 || selector == 0xff) return;
    
    float3 vertices[12];
    float3 normals[12];
    [unroll]
    for (i = 0; i < 12; i++)
    {
        uint2 pair = EdgeVertexPair(i);
        float4 sample1 = samples[pair.x];
        float4 sample2 = samples[pair.y];
        const float3 vertex1 = id + CubeVertex(pair.x);
        const float3 vertex2 = id + CubeVertex(pair.y);
        
        // Interpolate based on zero crossing
        const float param = sample1.w / (sample1.w - sample2.w);
        vertices[i] = TransformPoint(lerp(vertex1, vertex2, param));
        
        // Interpolate gradients and normalize to get normal
        float3 normal = -normalize(lerp(sample1.xyz, sample2.xyz, param));
        
        // Apply flip normals if requested
        normals[i] = normal;
    }
    
    const uint2 tri_data = TriangleTable[selector];
    [unroll]
    for (i = 0; i < 15; i += 3)
    {
        uint e3;
        uint e2;
        uint e1;
        e3 = EdgeIndexFromTriangleTable(tri_data, i);
        e2 = EdgeIndexFromTriangleTable(tri_data, i + 1);
        e1 = EdgeIndexFromTriangleTable(tri_data, i + 2);
        // e1 = EdgeIndexFromTriangleTable(tri_data, i);
        // e2 = EdgeIndexFromTriangleTable(tri_data, i + 1);
        // e3 = EdgeIndexFromTriangleTable(tri_data, i + 2);
        if (e1 != 15)
        {
            const uint count = Counter.IncrementCounter();
            if (count < MaxTriangle)
            {
                const uint vidx = count * 3;
                WriteVertex(vidx + 0, vertices[e1], normals[e1]);
                WriteVertex(vidx + 1, vertices[e2], normals[e2]);
                WriteVertex(vidx + 2, vertices[e3], normals[e3]);
                WriteIndices(vidx, uint3(vidx, vidx + 1, vidx + 2));
            }
        }
    }
}

[numthreads(64, 1, 1)]
void Clear(uint id : SV_DispatchThreadID)
{
    while (true)
    {
        const  uint count = Counter.IncrementCounter();
        if (count >= MaxTriangle) break;
        const  uint vidx = count * 3;
        WriteVertex(vidx + 0, 0, 0);
        WriteVertex(vidx + 1, 0, 0);
        WriteVertex(vidx + 2, 0, 0);
        WriteIndices(vidx, uint3(0, 0, 0));
    }
}